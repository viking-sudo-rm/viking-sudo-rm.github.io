<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://lambdaviking.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://lambdaviking.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-10-01T11:18:40-07:00</updated><id>https://lambdaviking.com/feed.xml</id><title type="html">blank</title><subtitle>This is the personal website of William Merrill </subtitle><entry><title type="html">My Dissertation is Now Online!</title><link href="https://lambdaviking.com/blog/2025/dissertation/" rel="alternate" type="text/html" title="My Dissertation is Now Online!"/><published>2025-10-01T00:00:00-07:00</published><updated>2025-10-01T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2025/dissertation</id><content type="html" xml:base="https://lambdaviking.com/blog/2025/dissertation/"><![CDATA[ <p>My dissertation is now available <a href="/assets/pdf/dissertation.pdf">here</a>!</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[A theory of the computational power and limitations of language modeling architectures]]></summary></entry><entry><title type="html">Project: Improved Adversarial Robustness via Abstract Interpretation</title><link href="https://lambdaviking.com/blog/2022/improved-adversarial-robustness/" rel="alternate" type="text/html" title="Project: Improved Adversarial Robustness via Abstract Interpretation"/><published>2022-04-15T00:00:00-07:00</published><updated>2022-04-15T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2022/improved-adversarial-robustness</id><content type="html" xml:base="https://lambdaviking.com/blog/2022/improved-adversarial-robustness/"><![CDATA[<p>This paper improves methods for certifying the adversarial robustness of neural networks using techniques from abstract interpretation. The idea is to pass regions of the input space (rather than specific inputs) through the network, and compute an upper bound on the loss over that region. We introduce some practical techniques to get a tighter upper bound on this loss compared to previous work.</p> <p>You can find the final report <a href="assets/pdf/foml-final-project.pdf">here</a>. I had a lot of fun working on this project along with my coauthors Zachary DeStefano and Ildebrando Magnani!</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[A course project for Foundations of Machine Learning at NYU]]></summary></entry><entry><title type="html">A Formal Hierarchy of RNN Architectures</title><link href="https://lambdaviking.com/blog/2020/formal-hierarchy-of-rnn-architectures/" rel="alternate" type="text/html" title="A Formal Hierarchy of RNN Architectures"/><published>2020-04-16T00:00:00-07:00</published><updated>2020-04-16T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2020/formal-hierarchy-of-rnn-architectures</id><content type="html" xml:base="https://lambdaviking.com/blog/2020/formal-hierarchy-of-rnn-architectures/"><![CDATA[<p>This post is about <a href="https://arxiv.org/abs/2004.08500"><em>A Formal Hierarchy of RNN Architectures</em></a>, which was joint work between myself, Gail Weiss, Yoav Goldberg, Roy Schwartz, Noah Smith, and Eran Yahav. Compared to the original paper, this post is more of a summary, and will attempt to explain the significance of the results assuming less familiarity with formal language theory.</p> <h2 id="background">Background</h2> <p>Understanding the practical capacity of neural network architectures is an important question for both the design of new architectures and the interpretability of current ones. By “practical capacity”, we mean the classes of tasks that an architecture can discover solutions to via standard training methods. Since we are mostly interested in NLP here, another way to describe this is the types of grammars that a trained neural network can learn to implement. It has been known since <a href="https://dl.acm.org/doi/10.1145/130385.130432">Siegelmann and Sontag (1992)</a> that RNNs with infinite time and precision are Turing-complete; however, these unrealistic assumptions make this a bad formal model for practical learnable capacity.</p> <p>Over the last year or two, several works have addressed this by relating deep NLP architectures like RNNs to existing formal models in automata theory. <a href="https://arxiv.org/abs/1805.04908">Weiss et al. (2018)</a> showed a connection between LSTMs and counter machines (CMs), and demonstrated how LSTMs learn to count to solve certain formal tasks that other RNNs cannot solve. Building on this, <a href="https://arxiv.org/abs/1906.01615">Merrill (2019)</a> formalized the notion of a saturated network (a finite-precision approximation of a continuous RNN) and related the capacity of different saturated RNNs to different classes of formal languages. <a href="https://arxiv.org/abs/1808.09357">Peng et al. (2018)</a> explored RNN capacity along a different axis: whether or not their internal computation can be simulated by a weighted finite state machine (WFA).</p> <h2 id="the-hierarchy">The Hierarchy</h2> <p>The goal of this paper is to unify these independent threads of research by further exploring the connection between formal models like saturated RNNs, CMs, and WFAs. We place all of these models into a two dimensional hierarchy defined by two formal properties: rational recurrence and space complexity. As defined by <a href="https://arxiv.org/abs/1808.09357">Peng et al. (2019)</a>, an RNN is <em>rationally recurrent</em> if its recurrent state can be computed by a WFA. <em>Space complexity</em>, related to the concept in analysis of algorithms, measures how much memory is available to a model.</p> <p>We present new results characterizing models in terms of these properties. For example, we prove the saturated LSTM is not rationally recurrent, which was previously an open question. We also show that general CMs are not rationally recurrent. However, we explore restricted classes of counter machines that are. While the main focus of the paper is on RNNs, we also present results analyzing memory networks and transformers in the same terms. Together, these results provide a hierarchy of RNNS and related models in terms of the functions that their hidden states can express.</p> <h2 id="language-expressiveness">Language Expressiveness</h2> <p>Once we have derived these characterizations, we use them to demonstrate formal languages that separate the capacities of different RNNs. We add a 1 or 2-layer feedforward “pooler” after the final RNN state and view this full model as a language acceptor. Here are some of the results in this vein, stated more formally. Let $D_k$ denote the capacity of an RNN with a $k$-layer pooler, and let s-$X$ denote the saturated version of architecture $X$.</p> <p>\(a^nb^n \in D_1(\textrm{s-LSTM})\) \(a^nb^n \not\in D_1(\textrm{s-QRNN})\)</p> <p>The QRNN with a 1-layer pooler cannot recognize $a^nb^n$, whereas the LSTM can.</p> \[a^nb^n \in D_1(\textrm{WFA})\] <p>While the rationally recurrent s-QRNN cannot recognize $a^nb^n$, a WFA actually can! We provide an existence proof using some linear algebra, and then provide a method through which the proof can be extended to construct an example WFA.</p> \[a^nb^n \in D_2(\textrm{s-QRNN})\] <p>Adding a second linear layer (or using two s-QRNN layers) allows us to recognize $a^nb^n$ with an s-QRNN. Does this mean the hierarchy dissolves as the pooler is strengthened?</p> <p>\(a^nb^n\Sigma^* \in D_1(\textrm{s-LSTM})\) \(a^nb^n\Sigma^* \not\in D(\textrm{s-QRNN}) \; \textrm{for any $D$}\)</p> <p>No, the hierarchy persists, even for stronger decoders. We provide a simple extension of $a^nb^n$ that can be recognized by an s-LSTM with a 1-layer pooler, but can never be recognized by an s-QRNN, no matter how many layers the pooler has. We dub the technique used to prove this the <em>suffix attack</em>. It exploits the fact that the QRNN (compared to the LSTM) is fundamentally unable to detect when its state has reached an accepting configuration–thus, it cannot “stop” updating when the strings are padded with an arbitrary suffix. Since this is a general property, it can be directly adapted to other formal languages.</p> <h2 id="experiments">Experiments</h2> <p>Finally, we run experiments testing whether unsaturated networks trained by gradient descent can learn variants of $a^nb^n$ and $a^nb^n\Sigma^*$. In every case, we find that the capacity of the saturated networks correctly predicts the outcome of the experiments. Thus, while our theoretical results largely focus on saturated networks, it seems that they also describe the practical behavior learned by unsaturated ones.</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[Summary of the ACL 2020 paper]]></summary></entry><entry><title type="html">Theory of Saturated Neural Networks</title><link href="https://lambdaviking.com/blog/2019/theory-of-saturated-neural-networks/" rel="alternate" type="text/html" title="Theory of Saturated Neural Networks"/><published>2019-09-06T00:00:00-07:00</published><updated>2019-09-06T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2019/theory-of-saturated-neural-networks</id><content type="html" xml:base="https://lambdaviking.com/blog/2019/theory-of-saturated-neural-networks/"><![CDATA[<p>The main idea of my paper <a href="https://arxiv.org/abs/1906.01615">Sequential Neural Networks as Automata</a> is that, if we making some simplifying assumptions about how neural networks work, we can derive a theory of network expressiveness (what formal languages can different architectures model?) that seems to agree with the classes of formal languages that different networks can learn when trained by gradient descent. Thus, this restricted theoretical capacity seems to be (potentially) a good proxy for the empirical learnable capacity of various networks.</p> <h2 id="saturated-networks">Saturated Networks</h2> <p>In the paper, I referred to the simplified network whose capacity we can analyze as an <em>asymptotic</em> network. However, after talking with Gail Weiss, I now believe the term <em>saturated</em> is more descriptive, and plan to use this term going forward.</p> <p>A neural network is a function $f(x, \theta)$ that is almost-everywhere differentiable with respect to the parameters $\theta$. Given such a function, we derive the saturated network $f’$ as</p> \[f'(x, \theta) = \lim_{N \rightarrow \infty} f(x, N\theta) .\] <p>We define $ f’(x, \theta) $ over the domain of $(x, \theta)$ for which the limit above exists.</p> <p>In a neural network, the effect of this transformation is to discretize all of the activations. For example, consider a neuron:</p> \[\sigma(wx + b)\] <p>where $\sigma$ is the sigmoid function. When we take the limit of $\sigma(Nwx + Nb)$, the output of the neuron approaches either $0$ or $1$. This is what I mean by <em>discretization</em>.</p> <p>After applying this discretization to the full network, we can analyze the computational capacity of the resulting discrete automaton. We also define a notion of space complexity associated with these saturated networks in the paper. Intuitively, this measure of complexity is just the number of configurations that the saturated network can have after reading a sequence of length $n$. For more details on this, consult <a href="https://arxiv.org/abs/1906.01615">the paper</a>.</p> <h2 id="summary-of-results">Summary of Results</h2> <p>By $L(M)$, we denote the set of formal languages that a machine $M$ can accept. Some key capacity results from the paper are as follows:</p> <ul> <li>$L(\textrm{ConvNet})$ is a proper subset of the regular languages</li> <li>$L(\textrm{RNN})$ is exactly the regular languages</li> <li>$L(\textrm{GRU})$ is exactly the regular languages</li> <li>$L(\textrm{LSTM})$ is a superset of the regular languages, and a subset of the real-time counter languages</li> </ul> <p>The core results about the configuration complexity, some of which are analogous, are:</p> <ul> <li>ConvNet has $O(1)$ configurations</li> <li>RNN has $O(1)$ configurations</li> <li>GRU has $O(1)$ configurations</li> <li>LSTM has $O(n^k)$ configurations for hidden size $k$</li> <li>Attention has $2^{O(n)}$ configurations</li> <li><a href="https://github.com/viking-sudo-rm/stacknn-core">StackNN</a> has $2^{O(n)}$ configurations</li> </ul> <p>There are some other results about attention/transformers that I’m not going to get into here, since they’re not so neat. If you’re interested though, I refer you to Section 4 of <a href="https://arxiv.org/abs/1906.01615">the paper</a>.</p> <h2 id="empirical-evidence">Empirical Evidence</h2> <h3 id="positive-evidence">Positive Evidence</h3> <p>The development of this theory was motivated by past empirical results about what RNNs are able to learn. Two types of tasks (counting and reversing) serve as relevant diagnostics for assessing the computational power of different architectures.</p> <p><a href="https://arxiv.org/abs/1805.04908">Weiss et al.</a> show that LSTMs can learn to count, whereas RNNs and GRUs do not. Similarly, <a href="https://arxiv.org/abs/1906.03648">Sugzgun et al.</a> observe that LSTMs can learn the 1-Dyck counter language, whereas other RNNs do not. This is predicted by the theory since saturated LSTMs can do counting, but saturated RNNs and GRUs are finite state.</p> <p><a href="https://arxiv.org/abs/1809.02836">Hao et al.</a> show how stack neural networks can solve the (beyond counter language) task of reversing a string, whereas LSTMs fail badly on this. In my paper, I also showed that attention can solve this task. Both of the results are predicted by the theory, since stack neural networks and attention allow for exponential configurations, which are needed to reverse a string, whereas LSTMs are limited to polynomial configurations.</p> <h3 id="negative-evidence">Negative Evidence</h3> <p>While I found that regularized neural networks display the counting pattern reported by <a href="https://arxiv.org/abs/1805.04908">Weiss et al.</a>, I also found that the unregularized LSTM, GRU, and RNN can all learn to model the language $a^nb^nc$, which requires counting. Thus, it might be more precise to say that the saturated theory seems to describe the learnable capacity of <em>regularized</em> networks. One possible interpretation of this is that the constraints imposed by regularization prevent the network from learning strategies beyond the saturated capacity.</p> <h2 id="proof-sketches">Proof Sketches</h2> <h3 id="rnn-capacity-and-complexity">RNN Capacity and Complexity</h3> <p>To show that $L(\textrm{RNN})$ is the regular languages, we show two directions of containment.</p> <p>First, we prove that the the regular languages are an upper bound. We do this by showing that the configuration complexity of the RNN is finite, i.e. $O(1)$. Since each neuron has two possible values ($-1$ and $1$), and there are $k$ neurons in the state, the number of configurations of the state vector is $O(2^k) = O(1)$.</p> <p>The other direction is a little more complicated. We need to construct an RNN to simulate an arbitrary finite state machine. A construction for this is provided in Lemma B.1.</p> <h3 id="lstm-capacity-and-complexity">LSTM Capacity and Complexity</h3> <p>In the LSTM case, even when we discretize the network, we get a model with more than finite state. This is because the LSTM’s gating architecture is capable of counting (<a href="https://arxiv.org/abs/1805.04908">Weiss et al.</a>, 2018).</p> <p>To show that the counter languages are an upper bound, we write the saturated gate network for a particular counter state neuron $c$ as follows:</p> \[\underset{N \rightarrow \infty}{\lim} c_t\] \[= \underset{N \rightarrow \infty}{\lim} fc_{t-1} + i{\tilde c}_t\] \[= \underset{N \rightarrow \infty}{\lim} ac_{t-1} + b\] <p>where $a$ is $0$ or $1$ and $b$ is $-1$, $0$, or $1$. This equation parameterizes a real-time counter machine update. Thus, the counter languages are an upper bound on the saturated LSTM capacity.</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[Summarizing Sequential Neural Networks as Automata]]></summary></entry><entry><title type="html">The State of Interpretability in NLP</title><link href="https://lambdaviking.com/blog/2019/state-of-interpretability-in-nlp/" rel="alternate" type="text/html" title="The State of Interpretability in NLP"/><published>2019-08-06T00:00:00-07:00</published><updated>2019-08-06T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2019/state-of-interpretability-in-nlp</id><content type="html" xml:base="https://lambdaviking.com/blog/2019/state-of-interpretability-in-nlp/"><![CDATA[<p>This post is a summary of my thoughts and experiences at ACL 2019, focused around the theme of interpretability. After spending most of the summer thinking about things besides neural networks, I was abruptly thrown back into things upon arriving in Florence. I spent a lot of my downtime with friends from Yale that I was staying with. On the other hand, I also met my future colleagues at AI2 and many other young researchers who are interested in similar issues of the interpretability and formal analysis of neural networks. In this way, the conference felt like a soft threshold between old and new.</p> <p>There were plenty of exciting things going on at the main conference, from work on incorporated graph representations into transformers to the development of more energy-efficient non-autoregressive NLP models. In this post, though, I’m going to focus on parts that I was most directly involved in, which were the Blackbox NLP workshop on interpretability and the Deep Learning and Formal Languages (DELFOL) workshop.</p> <h1 id="blackbox-nlp">Blackbox NLP</h1> <p>This was the second iteration of the Blackbox workshop. While the last Blackbox at EMNLP was also quite large and interesting, it had felt to me like a quite interdisciplinary meeting of researchers doing very different things. In contrast, I got the impression at this year’s meeting that a community of interpretability-minded researchers with similar goals and methods has formed. This is consistent with the wider interest that interpretability has sparked in the larger NLP community and the number of interpretability papers presented in the main conference. In the closing panel of the workshop, it was mentioned that perhaps interpretability would become a session within the conference at the next ACL meeting instead of a supplementary workshop.</p> <p>One of the main goals of interpretability research is to assess what kinds of information is encoded in different representations within a neural network. In particular, people (including myself) are interested in how different models encode grammatical information. Several methods were discussed for addressing this question, including attention, probing, representational similarity analysis (RSA).</p> <h2 id="attention">Attention</h2> <p>A classical way of interpreting whether networks encode grammatical information is by looking at attention alignments. For example, we might expect that, if there is a dependency between words $i$ and $j$, then position $i$ in the network should attend to position $j$. While this probably works to some degree, attention maps can often get messy. Also, as <a href="https://arxiv.org/abs/1906.03731">Serrano et al.</a> pointed out in their work at the main conference, perturbing the attention distribution has surprisingly little effect on a network’s behavior. Thus, we might want to look to other methods for interpreting neural representations.</p> <h2 id="probing">Probing</h2> <p>Probing refers to using a linear classifier to try to recover some kind of information, say part of speech information, from some representation within a model. This has been a standard way of interpreting neural representations throughout the last year. The underlying assumption is that, if information is recoverable in a single linear layer, then it is probably strongly encoded in the representation. As was pointed out to me by <a href="https://homes.cs.washington.edu/~jkasai/">Jungo Kasai</a>, one pitfall of this method is that it just assesses whether or not the information of interest is encoded in a representation, not to what degree it is there. For example, if a small amount of the representation in some network is representing grammatical information, whereas the rest of it is representing spurious correlations between words, probing would still suggest that that layer is encoding grammar. In such a case, is it really reasonable to conclude that a grammatical representation is an important part of the behavior which the network is learning?</p> <h2 id="rsa">RSA</h2> <p>An alternate approach to the same problem is RSA, which is not to be confused with the cryptographic protocol of the same name. RSA sidesteps the issue with probing by measuring the degree to which two representations are correlated, not whether the information from one can be recovered from the other.</p> <p>Formally, RSA is a method of computing the similarity between two representations $X$ and $Y$. We assume that we do not have the direct ability to compare $x$ to $y$, but instead have two internally defined similarity measures $d_X(x_1, x_2)$ and $d_Y(y_1, y_2)$. These measures need not be symmetric.</p> <p>To get an overall measure of similarity, we compute a similar matrices $M(X)$ and $M(Y)$ where</p> \[M(X)_{ij} = d_X(x_i, x_j)\] <p>and analogously for $Y$. Once we have these matrices, we compute an overall measure of similarity by taking the correlation between them. I find RSA to be a quite exciting method for future research, as it avoids some of the pitfalls of probing while also being very easy (perhaps easier than probing) to implement. This is not to say that probing should be abandoned completely, as being able to verify the same results with different methods increases their confidence. I recall hearing a talk at ACL in which RSA was already applied to transformer representations and replicated probing findings, although I unfortunately cannot find the paper which reported this.</p> <h2 id="conclusion">Conclusion</h2> <p>Probing and RSA are two good methods for understanding what information is encoded in some representation within a trained network. This is still a slightly different question than asking what information is particular relevant for the decision that a network makes given some input, which can be addressed using gradient methods or perturbation studies. I think that interpreting representations and interpreting decisions are both interesting questions.</p> <p>Additionally, both of these questions have analogs in the formal domain, where we can analyze what representations different neural network hidden states can encode, or what classes of formal languages a certain architecture can accept. As others at ACL also mentioned, I would like to see future work connecting empirical interpretability research to the formal analysis that has been done.</p> <p>Finally, as many people expressed during the conference, I think that a good goal for the next year is progress towards constructive interpretability work. In other words, our interpretation of networks should allow us to make smarter architectures.</p> <h1 id="delfol">DELFOL</h1> <p>DELFOL was the venue for formal work at ACL 2019. Given its somewhat esoteric topic, this workshop was quite small, but I found it really exciting. To me, the following three questions captured a lot of the work that people were presenting:</p> <ol> <li>Assess the learnable capacity of neural network models using empirical studies</li> <li>Identify formal properties of neural architectures that lead to different kinds of inductive bias or learnable/representational capacity</li> <li>“Distill” neural network models into smaller, more interpretable discrete models</li> </ol> <h2 id="empirical-experiments-about-learnability">Empirical Experiments about Learnability</h2> <p>On the empirical front, <a href="https://arxiv.org/abs/1906.03648">Suzgun et al.</a> reported that LSTMs generalizably learn to model the 1-Dyck language, which consists of parenthetic expressions with one type of parentheses. Other types of RNNs, on the other hand, were not able to do this. Additionally, LSTMs could not model 2-Dyck, but could model independently mixed versions of 1-Dyck.</p> <p>Since 1-Dyck is a counter language, this is further evidence that LSTMs can count, unlike other kinds of RNNs. Additionally, since 2-Dyck is a context-free language that requires more memory than is available to counter machines, we have further experimental evidence that LSTM memory, like counter machine memory, is not sufficient for complex hierarchical representations. As <a href="https://bobfrank1.github.io/">Bob Frank</a> summarized in his invited talk at DELFOL, LSTMs also struggle to do other memory intensive context-free things, like reversing strings.</p> <p>While <a href="https://arxiv.org/abs/1906.01615">my paper</a> at DELFOL was mostly theoretical results, I also had some experimental stuff that agreed with these conclusions.</p> <h2 id="formal-analysis-of-inductive-bias-and-capacity">Formal Analysis of Inductive Bias and Capacity</h2> <h3 id="saturated-networks">Saturated Networks</h3> <p>Building on work done by <a href="https://arxiv.org/abs/1805.04908">Weiss et al.</a>, <a href="https://arxiv.org/abs/1906.01615">my paper</a> at DELFOL developed a theory of <strong>saturated networks</strong>, or networks where the activation functions are restricted to their asymptotic values instead of intermediate rational values. I proved that saturated RNNs and GRUs are equivalent to finite-state automata in capacity, whereas saturated LSTMs are equivalent to a restricted class of counter machines. <a href="https://bobfrank1.github.io/">Bob Frank</a> also synthesized my results and Weiss et al.’s results in his invited talk.</p> <p>I think these theoretical results about saturated networks are interesting because they agree with empirical results (see previous section) about the types of languages that natural networks are empirically able to learn and generalize. This suggests that the capacity of the saturated network might represent something like the inductive bias or effective learnable capacity of the general network.</p> <h3 id="other-formal-properties">Other Formal Properties</h3> <p>In his talk, <a href="https://bobfrank1.github.io/">Bob Frank</a> also mentioned other ways of understanding the abilities of different networks. In particular, he mentioned studying the closure properties of representable or learnable languages as a potential way to build a theory. Another notable formal property that he mentioned was semilinearity. In his talk, <a href="https://homes.cs.washington.edu/~nasmith/">Noah Smith</a> mentioned rational recurrence as one way to analyze different neural architectures. While less linguistically motivated, this property is nice because of its connections to classical finite-state methods in NLP and the interpretability that comes along with this.</p> <h3 id="distillation">Distillation</h3> <p>Finally, a general theme at DELFOL that I found especially interesting was distillation. This refers to converting a neural network to a smaller and more interpretable discrete model which approximates the same behavior. This has a variety of practical benefits: deployment on smaller devices, interpretability, and possibly regularization, to name a few. I think one of the reasons why I find this topic interesting is because it is a way for theory to provide very concrete solutions to practical problems.</p> <p>As I see it, there are two main ways that distillation has been done. <a href="https://arxiv.org/abs/1711.09576">Weiss et al.</a> pioneered the <strong>query-based</strong> approach, which involves using the <a href="https://people.eecs.berkeley.edu/~dawnsong/teaching/s10/papers/angluin87.pdf">L* algorithm</a> to learn a finite-state machine using black-box queries to a neural network. The other type of distillation is <strong>spectral</strong>, which <a href="https://pageperso.lis-lab.fr/~remi.eyraud/WP/">Rémi Eyraud</a> spoke about at DELFOL. This involves building a Hankel matrix for some language and then using SVD to extract a smaller matrix representing a weighted finite-state automaton. While these are the two methods that have been investigated, I’m interested in other ways to achieve distillation, and I have been doing some preliminary experiments using other methods. More on that to come!</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[Thoughts from my experience at ACL 2019]]></summary></entry><entry><title type="html">Translation of the Wanderer</title><link href="https://lambdaviking.com/blog/2019/wanderer/" rel="alternate" type="text/html" title="Translation of the Wanderer"/><published>2019-07-13T00:00:00-07:00</published><updated>2019-07-13T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2019/wanderer</id><content type="html" xml:base="https://lambdaviking.com/blog/2019/wanderer/"><![CDATA[<p><em>You can find the original Old English <a href="http://www.anglo-saxons.net/hwaet/?do=get&amp;type=text&amp;id=wdr">here</a>.</em></p> <p>Often the outcast<br/> awaits his grace,<br/> the Lord’s mercy,<br/> though he, sorrow-minded,<br/> must turn his oars<br/> along the waters,<br/> wade the path of exile.<br/> Fate goes always as it must!</p> <p>So spoke the earth-stepper,<br/> mindful of his misfortunes,<br/> of wrathful slaughter,<br/> the death of his comrades:</p> <p>Often in the morning,<br/> I had to discuss<br/> my every trouble alone.<br/> There is no one living<br/> that I dare open my innermost thought to.<br/> Truly I know<br/> that it ought to be among men,<br/> the noble custom,<br/> where one secures the chest of his spirit,<br/> hordes his treasure case,<br/> thinks and speaks freely.<br/> The weary spirit cannot<br/> withstand fate,<br/> nor does the bitter mind<br/> help do any good.<br/> So the glory-yearning<br/> often lock away their dreary<br/> thoughts in their breast-coffins.<br/> So I,<br/> often wretched<br/> and besorrowed,<br/> have had to seal away<br/> my thoughts from kinsmen,<br/> since, long ago,<br/> I sealed my lord<br/> in the darkness of the earth<br/> and from there travelled<br/> winter-minded<br/> over the frozen waves,<br/> sought, hall-lacking,<br/> a treasure-giver,<br/> wherever far or near<br/> I might find someone<br/> in the meadhall<br/> who knew me,<br/> or was willing to console<br/> me, the friendless one,<br/> wow me with wonders.</p> <p>He who has known it understands<br/> how cruel sorrow is as a companion<br/> for the one who has<br/> few beloved friends.<br/> Exile wraps him,<br/> not rings of gold,<br/> a frozen spirit,<br/> not the prosperity of the earth.<br/> He remembers hall-warriors<br/> and ring-givers,<br/> how his gold-giver<br/> treated him to feasting<br/> in his youth.<br/> How all that joy has died!<br/> And so he knows this,<br/> he who must for a long time<br/> forgo the counsel of his<br/> dear lord,<br/> when sorrow and sleep together<br/> wrap him up and bind him.<br/> He dreams in his head<br/> that he hugs and kisses<br/> his lord,<br/> and on his lord’s knee<br/> lie his hand and head,<br/> just as he, at times<br/> in days gone by,<br/> enjoyed the gift throne.<br/> Then he wakes back up<br/> a lordless man,<br/> he sees before him<br/> dusky waves,<br/> sea birds bathing,<br/> pruning their feathers,<br/> frost and snow falling,<br/> mixed in with hail.<br/> Then are that much heavier<br/> the wounds of his heart,<br/> grieving after his lord.<br/> His sorrow is renewed<br/> when his mind happens upon<br/> the memory of his kinsmen.<br/> He greets them with joy,<br/> eagerly looks over<br/> the gathering of men -<br/> but they always swim away.<br/> The journey of sailors<br/> never brings back many<br/> known stories.<br/> Grief is renewed<br/> for him who must<br/> always send his<br/> weary heart<br/> over the binding of the waves.</p> <p>Therefore I can’t think<br/> why my heart does not<br/> darken when I reflect<br/> on all the lives of men<br/> throughout this world,<br/> how they suddenly<br/> left the hall floor,<br/> those proud thanes.<br/> So each day this Middle Earth<br/> crumbles and decays.<br/> Therefore a man cannot become<br/> wise before he has a share<br/> of winters in the world.<br/> A wise man must be patient,<br/> must not be too reckless,<br/> nor too word-hasty<br/> nor too weak a warrior,<br/> nor too rash,<br/> neither too fearful nor cheerful,<br/> nor too greedy of goods,<br/> and never too eager for boasting<br/> before he truly understands.<br/> A man must wait<br/> when he speaks oaths<br/> until the bold one<br/> truly knows<br/> where his heart’s intent<br/> will turn.<br/> A wise hero must realize<br/> how ghastly it will be<br/> when all the wealth of this world<br/> lies waste,<br/> as now in various places<br/> around this earth,<br/> walls stand<br/> blown by wind,<br/> covered in snow,<br/> storm-wrecked ruins.<br/> The halls decay,<br/> their leader lies dead,<br/> deprived of joy.<br/> The whole troop<br/> has proudly fallen by the wall.<br/> Some war took them,<br/> carried them on their way.<br/> One, a bird snatched off<br/> over the deep sea.<br/> Another, the grey wolf<br/> tore apart after his death.<br/> Another, buried<br/> dreary-faced<br/> in his grave.<br/> And so He destroyed this place,<br/> the Creator of men,<br/> until missing the noise<br/> of its residents,<br/> the old work of giants<br/> stood idle.</p> <p>He who wisely reflected<br/> on this ruin,<br/> and deeply pondered<br/> this dark life,<br/> wise in experience,<br/> distantly remembered<br/> much slaying,<br/> and spoke these words:</p> <p>Where is the horse? Where is the rider?<br/> Where is the treasure-giver?<br/> Where are the hall’s joys?<br/> Alas, the bright cups!<br/> Alas, the warrior in mail!<br/> How that time has departed,<br/> dark under night’s helm,<br/> as if it never were.<br/> Now stands as a trace of<br/> the dear warband<br/> a wonderously high wall,<br/> snakingly woven.<br/> The warriors have been snatched away<br/> by the honor of spears,<br/> slaughter-seeking weapons,<br/> that famous fate,<br/> and storms clash against<br/> these stone cliffs,<br/> falling frost<br/> grips the earth,<br/> the clamor of winter.<br/> Then darkness comes;<br/> night’s shadow deepens.<br/> From the north approaches<br/> a rough hail storm,<br/> hostile to men.<br/> All is troubled<br/> in this earthly kingdom,<br/> the tide of fate<br/> turns the world under the heavens.<br/> Here is wealth fleeting.<br/> Here are companions fleeting.<br/> Here is man himself fleeting.<br/> Here is kinsman fleeting.<br/> Every foundation of this world<br/> becomes void and vain.</p> <p>So spoke the wise one in his mind.<br/> He sat apart in thought.<br/> Good is he who holds onto his faith,<br/> and a warrior must never speak<br/> the grievances of his heart too quickly,<br/> unless he already knows the cure.<br/> A hero must act with conviction.<br/> Good is he who seeks mercy,<br/> the Father’s grace in Heaven,<br/> where permanence stands for us all.</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[My amateur translation of the Old English poem]]></summary></entry><entry><title type="html">Voynich2Vec: Word2Vec Analysis of the Voynich Manuscript</title><link href="https://lambdaviking.com/blog/2018/voynich2vec/" rel="alternate" type="text/html" title="Voynich2Vec: Word2Vec Analysis of the Voynich Manuscript"/><published>2018-04-15T00:00:00-07:00</published><updated>2018-04-15T00:00:00-07:00</updated><id>https://lambdaviking.com/blog/2018/voynich2vec</id><content type="html" xml:base="https://lambdaviking.com/blog/2018/voynich2vec/"><![CDATA[<p>Last semester in school, I worked on a project where we attempted to build word embeddings from the Voynich manuscript and use them to learn something about the linguistic structure (or lack thereof) within the text. You can check out our <a href="https://github.com/viking-sudo-rm/voynich2vec">codebase</a> or our <a href="assets/pdf/yale/voynich2vec.pdf">paper</a>. The reason why this methodology is exciting is that building word embeddings is completely unsupervised. This makes it a very appealing methodology for decipherment-like tasks. If done properly, we should be able to visualize the word embedding space and understand something about the relationship between words and characters in the manuscript!</p> <p>However, several issues make this methodology more complicated for Voynich. First, there are problems with transcription and word and sentence segmentation. Several digitalized transcriptions of the manuscript exist, and they disagree in a surprising number of places. A second concern is the issue of data sparsity. Canonical methods for word embeddings are designed to be architecturally simple so that they can be applied to massive data sets (for example, all of Wikipedia). These models overcome their architectural shortcomings from being hit over the head with a lot of data: there is no inductive bias that tells them that <em>relocate</em> and <em>relocates</em> are systematically related, but if the model gets to see all of Wikipedia, it should be able to figure this out. On the other hand, in a low-resource setting like Voynich, the distribution of words is sparse enough that we probably will never see every form of each verb. We need a more complex model that has the ability to learn a generalizable notion of morphology. It seems feasible that there is enough signal in the data for a model to actually learn a meaningful model of Voynich morphosyntax even if the data is too sparse to build a meaningful representation of the syntactic space.</p> <p>There’s not much we can do to address the transcription concern except being principled about which transcription we adopt. However, there is recent work about building morphologically-informed word embeddings. In particular, our project utilized fastText embeddings, which were developed by Facebook research. FastText works by learning different embeddings for different subsequences of words and representing the embedding for the full word as a combination of these sub-embeddings. Intuitively, subsequences that are morphemes should contribute a meaningful vector to the full word vector, and subsequences that do not encode morphological information will have a representation close to zero. You can find the code to build these embeddings in the voynich2vec repository.</p> <p>Our original project tried to analyze these vectors in three different ways:</p> <ol> <li><strong>Morphosyntactic analysis.</strong> We looked at how words with common suffixes were distributed in the Voynich embedding space. If a suffix contributes to where the word can appear (i.e., it carries morphosyntactic information), then we would expect words ending in it to cluster closely. Conversely, if it does not contribute to where the word can appear, this should mean that it is just a common suffix but not a morpheme. Excitingly, we found that some suffixes displayed said clustering, but others did not. Also interestingly, we found that some similar suffixes clustered together, which suggests that they are two different surface realizations of the same morpheme.</li> <li><strong>Topic modelling.</strong> We can build a bag-of-words representation of some section of the manuscript by summing the embeddings for the words on that page. This sum could possibly be weighted by a metric like TF-IDF. We did this and got some clustering by section, but nothing very conclusive.</li> <li><strong>Unsupervised word alignment.</strong> We attempted to use a method called MUSE to align two word embedding spaces. If this worked, this could give as an approximate mapping from Voynichese words to Latin words. Sadly, it did not work. Unsupervised alignment methods like MUSE rely on massive corpora. In our case, Voynich was so small that we only got noise. There has also been work done on semi-supervised word embeddings where two embedding spaces can be fully aligned from a small set of seed words (for example, just the month names).</li> </ol> <p>Sadly, I haven’t been able to work on this project much since the beginning of the summer, but I’m keeping track of a central list of ideas for future work <a href="https://github.com/viking-sudo-rm/voynich2vec/issues">here</a>. In particular, I think the most promising question is to extend our preliminary work on morphosyntactic analysis. As I describe in one of the <a href="https://github.com/viking-sudo-rm/voynich2vec/issues/9">GitHub issues</a>, methods have been developed in the NLP literature for inducing morphology from a vector space of word embeddings. This method could be used to generate a full morphological profile of Voynichese.</p>]]></content><author><name>William Merrill</name></author><summary type="html"><![CDATA[Can NLP help us decipher the enigmatic manuscript?]]></summary></entry></feed>